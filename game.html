<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Block Blast</title>
  <style>
    body {
      font-family: sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-top: 30px;
      background-color: #f0f0f0;
    }
    h1 { margin-bottom: 10px; }
    #score { margin-bottom: 20px; font-size: 20px; }
    #grid {
      display: grid;
      grid-template-columns: repeat(10, 32px);
      grid-template-rows: repeat(10, 32px);
      gap: 2px;
      margin-bottom: 20px;
    }
    .cell {
      width: 32px;
      height: 32px;
      background-color: #fff;
      border: 1px solid #ccc;
    }
    .filled {
      background-color: #2ecc71;
      animation: pop 0.2s ease-in-out;
    }
    @keyframes pop {
      0% { transform: scale(0.6); opacity: 0.3; }
      100% { transform: scale(1); opacity: 1; }
    }
    #blocks {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .block {
      display: inline-block;
      padding: 5px;
      background-color: #ecf0f1;
      border: 1px solid #ccc;
      cursor: grab;
    }
    .block div {
      width: 28px;
      height: 28px;
      background-color: #3498db;
      margin: 1px;
    }
    .hidden { display: none; }
    #restart-btn {
      display: none;
      margin-top: 20px;
      padding: 10px 20px;
      font-size: 16px;
    }
    @media (max-width: 600px) {
      #grid {
        grid-template-columns: repeat(10, 24px);
        grid-template-rows: repeat(10, 24px);
        gap: 1px;
      }
      .cell {
        width: 24px;
        height: 24px;
      }
      .block div {
        width: 20px;
        height: 20px;
      }
      #restart-btn {
        font-size: 14px;
        padding: 8px 16px;
      }
    }
  </style>
</head>
<body>
  <h1>Block Blast</h1>
  <div id="score">Очки: 0</div>
  <div id="grid"></div>
  <div id="blocks"></div>
  <button id="restart-btn">Сыграть снова</button>
  <script>
    const gridSize = 10;
    const grid = document.getElementById('grid');
    const blocksContainer = document.getElementById('blocks');
    const scoreDisplay = document.getElementById('score');
    const restartBtn = document.getElementById('restart-btn');
    let score = 0;
    const soundPlace = new Audio('place.mp3');
    const soundLine = new Audio('line.mp3');
    const soundEnd = new Audio('end.mp3');

    const blockShapes = [
      [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]], [[1,1],[1,1]],
      [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]]
    ];

    const cells = [];
    for (let i = 0; i < gridSize * gridSize; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.index = i;
      grid.appendChild(cell);
      cells.push(cell);
    }

    function getCell(r, c) {
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) return null;
      return cells[r * gridSize + c];
    }

    function placeShape(index, shape) {
      const row = Math.floor(index / gridSize);
      const col = index % gridSize;
      const coords = [];

      for (let i = 0; i < shape.length; i++) {
        for (let j = 0; j < shape[i].length; j++) {
          if (shape[i][j]) {
            const r = row + i;
            const c = col + j;
            const cell = getCell(r, c);
            if (!cell || cell.classList.contains('filled')) return false;
            coords.push(cell);
          }
        }
      }
      coords.forEach(c => c.classList.add('filled'));
      soundPlace.play();
      return true;
    }

    function clearLines() {
      let cleared = 0;
      for (let i = 0; i < gridSize; i++) {
        let rowFull = true;
        let colFull = true;
        for (let j = 0; j < gridSize; j++) {
          if (!getCell(i, j).classList.contains('filled')) rowFull = false;
          if (!getCell(j, i).classList.contains('filled')) colFull = false;
        }
        if (rowFull) {
          for (let j = 0; j < gridSize; j++) getCell(i, j).classList.remove('filled');
          cleared++;
        }
        if (colFull) {
          for (let j = 0; j < gridSize; j++) getCell(j, i).classList.remove('filled');
          cleared++;
        }
      }
      if (cleared > 0) {
        soundLine.play();
        score += cleared * 10;
        updateScore();
      }
    }

    function updateScore() {
      scoreDisplay.textContent = 'Очки: ' + score;
    }

    function createBlock(shape) {
      const block = document.createElement('div');
      block.classList.add('block');
      block.dataset.shape = JSON.stringify(shape);
      shape.forEach(row => {
        const rowDiv = document.createElement('div');
        row.forEach(cell => {
          const el = document.createElement('div');
          if (!cell) el.style.visibility = 'hidden';
          rowDiv.appendChild(el);
        });
        block.appendChild(rowDiv);
      });
      block.draggable = true;
      block.addEventListener('dragstart', e => {
        e.dataTransfer.setData('shape', block.dataset.shape);
      });
      blocksContainer.appendChild(block);
    }

    function generateBlocks() {
      blocksContainer.innerHTML = '';
      for (let i = 0; i < 3; i++) {
        const shape = blockShapes[Math.floor(Math.random() * blockShapes.length)];
        createBlock(shape);
      }
    }

    function canPlaceShape(startIndex, shape) {
      const row = Math.floor(startIndex / gridSize);
      const col = startIndex % gridSize;
      for (let i = 0; i < shape.length; i++) {
        for (let j = 0; j < shape[i].length; j++) {
          if (shape[i][j]) {
            const r = row + i;
            const c = col + j;
            const cell = getCell(r, c);
            if (!cell || cell.classList.contains('filled')) return false;
          }
        }
      }
      return true;
    }

    function checkGameOver() {
      const blocks = [...blocksContainer.children].filter(b => !b.classList.contains('hidden'));
      for (const block of blocks) {
        const shape = JSON.parse(block.dataset.shape);
        for (let i = 0; i < gridSize * gridSize; i++) {
          if (canPlaceShape(i, shape)) return false;
        }
      }
      return true;
    }

    function showGameOver() {
      const msg = document.createElement('div');
      msg.id = 'game-over-msg';
      msg.textContent = 'Игра окончена!';
      msg.style.fontSize = '28px';
      msg.style.color = '#e74c3c';
      msg.style.marginTop = '20px';
      document.body.appendChild(msg);
      soundEnd.play();
      cells.forEach(c => c.replaceWith(c.cloneNode(true)));
      blocksContainer.innerHTML = '';
      restartBtn.style.display = 'inline-block';
    }

    restartBtn.addEventListener('click', () => {
      cells.forEach(cell => cell.classList.remove('filled'));
      const msg = document.getElementById('game-over-msg');
      if (msg) msg.remove();
      cells.forEach(cell => {
        cell.addEventListener('dragover', e => e.preventDefault());
        cell.addEventListener('drop', e => {
          e.preventDefault();
          const shape = JSON.parse(e.dataTransfer.getData('shape'));
          const success = placeShape(parseInt(cell.dataset.index), shape);
          if (success) {
            clearLines();
            e.target.closest('.block').classList.add('hidden');
            if ([...blocksContainer.children].every(el => el.classList.contains('hidden'))) {
              generateBlocks();
              if (checkGameOver()) showGameOver();
            }
          }
        });
      });
      score = 0;
      updateScore();
      generateBlocks();
      restartBtn.style.display = 'none';
    });

    cells.forEach(cell => {
      cell.addEventListener('dragover', e => e.preventDefault());
      cell.addEventListener('drop', e => {
        e.preventDefault();
        const shape = JSON.parse(e.dataTransfer.getData('shape'));
        const success = placeShape(parseInt(cell.dataset.index), shape);
        if (success) {
          clearLines();
          e.target.closest('.block').classList.add('hidden');
          if ([...blocksContainer.children].every(el => el.classList.contains('hidden'))) {
            generateBlocks();
            if (checkGameOver()) showGameOver();
          }
        }
      });
    });

    generateBlocks();
  </script>
</body>
</html>
