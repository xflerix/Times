<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Block Blast Deluxe</title>
  <style>
    .block {
      display: inline-grid;
      grid-auto-rows: 28px;
      background: #fefefe;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      cursor: grab;
    }
    .block-row {
      display: flex;
    }
    
    body {
      font-family: 'Segoe UI', sans-serif;
      background: linear-gradient(to bottom, #dfe9f3, #ffffff);
      display: flex;
      flex-direction: column;
      align-items: center;
      margin: 0;
      padding: 20px;
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 10px;
    }
    #score {
      font-size: 22px;
      margin-bottom: 15px;
      color: #34495e;
    }
    #grid {
      display: grid;
      grid-template-columns: repeat(10, 34px);
      grid-template-rows: repeat(10, 34px);
      gap: 2px;
      margin-bottom: 20px;
    }
    .cell {
      width: 34px;
      height: 34px;
      background-color: #ecf0f1;
      border-radius: 6px;
      box-shadow: inset 0 0 4px #bdc3c7;
    }
    .filled {
      background-color: #2980b9;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: transform 0.2s;
      animation: fadeIn 0.3s;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.7); }
      to { opacity: 1; transform: scale(1); }
    }
    #blocks {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
    }
    .block {
      display: inline-block;
      padding: 6px;
      background: #fefefe;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      cursor: grab;
    }
    .block div {
      width: 28px;
      height: 28px;
      background-color: #3498db;
      margin: 1px;
      border-radius: 4px;
    }
    .hidden {
      display: none;
    }
    #restart-btn {
      margin-top: 20px;
      padding: 12px 24px;
      font-size: 16px;
      background-color: #27ae60;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
    @media (max-width: 600px) {
      #grid {
        grid-template-columns: repeat(10, 26px);
        grid-template-rows: repeat(10, 26px);
      }
      .cell {
        width: 26px;
        height: 26px;
      }
      .block div {
        width: 20px;
        height: 20px;
      }
    }
  </style>
</head>
<body>
  <h1>Block Blast Deluxe</h1>
    <a href="index.html" style="
      margin-bottom: 20px;
      padding: 10px 20px;
      background: #bdc3c7;
      color: #2c3e50;
      text-decoration: none;
      border-radius: 6px;
      font-size: 16px;
      display: inline-block;
    ">Назад</a>
  <div id="score">Очки: 0</div>
  <div id="grid"></div>
  <div id="blocks"></div>
  <button id="restart-btn">Сыграть снова</button>
  <script>
    const gridSize = 10;
    const grid = document.getElementById('grid');
    const blocksContainer = document.getElementById('blocks');
    const scoreDisplay = document.getElementById('score');
    const restartBtn = document.getElementById('restart-btn');
    let score = 0;

    const blockShapes = [
      [[1]], [[1,1]], [[1],[1]], [[1,1,1]], [[1],[1],[1]], [[1,1],[1,1]],
      [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]], [[1,1,1],[0,1,0]], [[1,0],[1,1]],
      [[0,1],[1,1]], [[1,1,1,1]], [[1],[1],[1],[1]], [[1,1,1],[1,0,0]], [[1,1,1],[0,0,1]]
    ];

    const cells = [];
    for (let i = 0; i < gridSize * gridSize; i++) {
      const cell = document.createElement('div');
      cell.classList.add('cell');
      cell.dataset.index = i;
      grid.appendChild(cell);
      cells.push(cell);
    }

    function getCell(r, c) {
      if (r < 0 || r >= gridSize || c < 0 || c >= gridSize) return null;
      return cells[r * gridSize + c];
    }

    function placeShape(index, shape) {
      const row = Math.floor(index / gridSize);
      const col = index % gridSize;
      const coords = [];

      for (let i = 0; i < shape.length; i++) {
        for (let j = 0; j < shape[i].length; j++) {
          if (shape[i][j]) {
            const r = row + i;
            const c = col + j;
            const cell = getCell(r, c);
            if (!cell || cell.classList.contains('filled')) return false;
            coords.push(cell);
          }
        }
      }
      coords.forEach(c => c.classList.add('filled'));
      return true;
    }

    function clearLines() {
      let cleared = 0;
      for (let i = 0; i < gridSize; i++) {
        let rowFull = true;
        let colFull = true;
        for (let j = 0; j < gridSize; j++) {
          if (!getCell(i, j).classList.contains('filled')) rowFull = false;
          if (!getCell(j, i).classList.contains('filled')) colFull = false;
        }
        if (rowFull) {
          for (let j = 0; j < gridSize; j++) getCell(i, j).classList.remove('filled');
          cleared++;
        }
        if (colFull) {
          for (let j = 0; j < gridSize; j++) getCell(j, i).classList.remove('filled');
          cleared++;
        }
      }
      if (cleared > 0) {
        score += cleared * 10;
        updateScore();
      }
    }

    function updateScore() {
      scoreDisplay.textContent = 'Очки: ' + score;
    }

    function createBlock(shape) {
      const block = document.createElement('div');
      block.classList.add('block');
      block.dataset.shape = JSON.stringify(shape);
      shape.forEach(row => {
        const rowDiv = document.createElement('div');
        rowDiv.classList.add("block-row");
        row.forEach(cell => {
          const el = document.createElement('div');
          if (!cell) el.style.visibility = 'hidden';
          rowDiv.appendChild(el);
        });
        block.appendChild(rowDiv);
      });
      block.draggable = true;
      block.addEventListener('dragstart', e => {
        e.dataTransfer.setData('shape', block.dataset.shape);
      });
      blocksContainer.appendChild(block);
    }

    function generateBlocks() {
      blocksContainer.innerHTML = '';
      for (let i = 0; i < 3; i++) {
        const shape = blockShapes[Math.floor(Math.random() * blockShapes.length)];
        createBlock(shape);
      }
    }

    function canPlaceShape(startIndex, shape) {
      const row = Math.floor(startIndex / gridSize);
      const col = startIndex % gridSize;
      for (let i = 0; i < shape.length; i++) {
        for (let j = 0; j < shape[i].length; j++) {
          if (shape[i][j]) {
            const r = row + i;
            const c = col + j;
            const cell = getCell(r, c);
            if (!cell || cell.classList.contains('filled')) return false;
          }
        }
      }
      return true;
    }

    function checkGameOver() {
      const blocks = [...blocksContainer.children].filter(b => !b.classList.contains('hidden'));
      for (const block of blocks) {
        const shape = JSON.parse(block.dataset.shape);
        for (let i = 0; i < gridSize * gridSize; i++) {
          if (canPlaceShape(i, shape)) return false;
        }
      }
      return true;
    }

    function showGameOver() {
      const msg = document.createElement('div');
      msg.id = 'game-over-msg';
      msg.textContent = 'Игра окончена!';
      msg.style.fontSize = '28px';
      msg.style.color = '#c0392b';
      msg.style.marginTop = '20px';
      document.body.appendChild(msg);
      blocksContainer.innerHTML = '';
      restartBtn.style.display = 'inline-block';
    }

    restartBtn.addEventListener('click', () => {
      cells.forEach(cell => cell.classList.remove('filled'));
      const msg = document.getElementById('game-over-msg');
      if (msg) msg.remove();
      score = 0;
      updateScore();
      generateBlocks();
      restartBtn.style.display = 'none';
    });

    cells.forEach(cell => {
      cell.addEventListener('dragover', e => e.preventDefault());
      cell.addEventListener('drop', e => {
        e.preventDefault();
        const shape = JSON.parse(e.dataTransfer.getData('shape'));
        const success = placeShape(parseInt(cell.dataset.index), shape);
        if (success) {
          clearLines();
          e.target.closest('.block').classList.add('hidden');
          if ([...blocksContainer.children].every(el => el.classList.contains('hidden'))) {
            generateBlocks();
            if (checkGameOver()) showGameOver();
          }
        }
      });
    });

    generateBlocks();
  </script>
</body>
</html>
